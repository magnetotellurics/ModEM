!
!>    Forward  modeling class for 1D, used for creating boundary  data for 
!>     for 3D forward problem.    I am creating a single explicit claass; as
!>     as we develop alternative 1D Fwd instances (e.g., for CSEM, anisotropy)
!>     we might create an abstract base class and make this an extension, or
!>     just extend this class, overloading setup and solve routines
!
module Forward1D
    !
    use Constants
    use Grid1D
    use ModelParameter1D
    !
    type :: Forward1D_t
        !
        class( ModelParameter1D_t ), pointer :: sigma
        !
        real( kind=prec ) :: omega
        !
        contains
            !
            procedure, public :: setCond => setCondForward1D
            procedure, public :: setFreq => setFreqForward1D
            procedure, public :: solve => solveForward1D
            procedure, public :: gridedSolution => gridedSolutionForward1D
            !
    end type Forward1D_t
    !
    interface Forward1D_t
        module procedure Forward1D_ctor
    end interface Forward1D_t
    !
 contains
    !
    !> No subroutine briefing
	!
    function Forward1D_ctor( sigma ) result( self )
        !
        class( ModelParameter1D_t ), target, intent( in ) :: sigma
        !
        type( Forward1D_t ) :: self
        !
        !write( *, * ) "Constructor ModelParameter1D"
        !
        self%sigma => sigma
        !
    end function Forward1D_ctor
    !
    !> No subroutine briefing
    subroutine setCondForward1D( self, sigma )
        implicit none
        !
        class( Forward1D_t ), intent( inout ) :: self
        type( ModelParameter1D_t ), target, intent( in ) :: sigma
        !
        self%sigma => sigma
        !
    end subroutine setCondForward1D
    !
    !> No subroutine briefing
    subroutine setFreqForward1D( self, omega )
        implicit none
        !
        class( Forward1D_t ), intent( inout ) :: self
        real( kind=prec ), intent( in ) :: omega
        !
        self%omega = omega
        !
    end subroutine setFreqForward1D
    !
    !> No subroutine briefing
    subroutine solveForward1D( self, E1D )
        implicit none
        !
        class( Forward1D_t ), intent( in ) :: self
        complex( kind=prec ), intent( out ), dimension(:) :: E1D
        !
        integer :: ku, kl, nlayer, n, nz, lda, info, i, j, nRHS
        integer, allocatable, dimension(:) :: ipiv
        complex( kind=prec ), allocatable, dimension(:,:) :: A
        complex( kind=prec ), allocatable, dimension(:) :: beta
        real( kind=prec ), allocatable, dimension(:) :: h
        complex( kind=prec ), allocatable, dimension(:) :: b
        character( len=1 ) :: TRANS
        !
        !>  The system matrix is banded with two subdiagonals, and two superdiagonals
        TRANS = 'N'    !>  character string that controls ZGBTRS:
                        !>  N = solve base system Ax = b
                        !>  T = solve transposed system A'x = b
                        !>  C = solve Hermitian      A^* = b    
        ku = 2
        kl = 2
        lda = 2*kl+ku+1     !>    storage required for banded matrix
                    !>    factorization using ZGBTRF
        nlayer = self%sigma%ParamGrid%nz 
        nz = self%sigma%grid%nz
        n = 2*nlayer - 1 !>    number of unknowns to solve for
        !>    NOTE: we assume that the last layer (which will have finite thickness
        !>     in the ParamGrid) actually extends to infinity -- thus this thickness
        !>     is not really used in computations, only the bottom-layer conductivity

        !>    allocate arrays for computations: coefficient matrix, rhs, solution
        !>     E interpolated to numerical grid
        allocate(A(lda,n))
        allocate(b(n))
        allocate(ipiv(n))
        allocate(beta(nlayer))
        allocate(h(nlayer))
        !allocate(E1D(self%sigma%metric%grid%nz))    !>  probably should be allocated before
                                             !>    calling
        !>    compute complex beta coefcients, for each layer in ParamGrid
        !>    I am going to assume that paramType for 1D model parameter is always
        !>     LINEAR -- need to make sure that this is true when creating
        !>      or could add check/transformation here ...
        do i = 1,nlayer
            beta(i) = sqrt( isign * ONE_I * mu_0 * self%omega * self%sigma%CellCond(i) )
            h(i) = self%sigma%ParamGrid%dz(i)     !>    layer thickness -- last is not used
        enddo
           
        !>    create cofficient matrix -- layer by layer -- first and last are unique
        A = C_ZERO
        do i = 2,nlayer-1
           A(lda-3,2*i-1) = C_ONE
           A(lda-4,2*i) = C_ONE
           A(lda-2,2*i-1) = -beta(i)
           A(lda-3,2*i) = beta(i)
           A(lda-1,2*i-1) = -exp(-beta(i)*h(i))
           A(lda-2,2*i) = -exp(beta(i)*h(i))
           A(lda,2*i-1) = beta(i)*exp(-beta(i)*h(i))
           A(lda-1,2*i) = -beta(i)*exp(beta(i)*h(i))
        enddo

        !>    special case for first layer
        A(lda-2,1) = C_ONE
        A(lda-3,2) = C_ONE
        A(lda-1,1) = -exp(-beta(1)*h(1))
        A(lda-2,2) = -exp(beta(1)*h(1))
        A(lda,1) = beta(1)*exp(-beta(1)*h(1))
        A(lda-1,2) = -beta(1)*exp(beta(1)*h(1))

        !>  special case for last layer
        A(lda-3,2*nlayer-1) = C_ONE
        A(lda-2,2*nlayer-1) = -beta(i)

        !>    some debugging output
        !write( *, * ) 'nlayer,ku,kl,lda,n'
        !write( *, * ) nlayer,ku,kl,lda,n
        !write( *, * ) 'omega',self%omega
        !write( *, * ) 'Coefficient Matrix'
        !do i = 1,n
           !write(*,'(7(e11.3,e11.3,1x))') (A(j,i),j=1,lda)
        !enddo

        !>    create rhs
        b = C_ZERO
        b(1) = C_ONE
        nRHS = ONE
        !>    solve equations using lapack
        !>     LU decomposition of complex banded matrix
        call zgbtrf( n,n,ku,kl,A,lda,ipiv,info )
        call zgbtrs( TRANS,n,kl,ku,nRHS,A,lda,ipiv,b,n,info )
        !
        deallocate( ipiv )
        deallocate( A )
        !>  calculate E1D on model grid
        call self%GridedSolution( b, beta, h, E1D )
        !
        deallocate( beta )
        deallocate( h )
        deallocate( b )
        !
    end subroutine solveForward1D
    !
    !> No subroutine briefing
    subroutine gridedSolutionForward1D( self, b, beta, h, E1D )
        !>    given coefficients b, complex wavenumbers beta, layer thickness h
        !>    compute electric field solution E1D evaluated at grid levels
        !>    specfied in z, and normalized so that E1D(1) = 1.0
        class(Forward1D_t), intent( in ) :: self
        complex( kind=prec ), intent( in ), dimension(:) :: b, beta
        real( kind=prec ), intent( in ), dimension(:) :: h
        complex( kind=prec ), intent( out ), dimension(:) :: E1D
        !
        integer :: n,nlayer,nz,i,j,layerInd
        real( kind=prec ), allocatable, dimension(:) :: interfaceDepth, z
        complex( kind=prec ) :: d, u, scaleFactor
        real( kind=prec ) :: zLayer

        n = size(b)
        nlayer = size(beta)
        !
        z = self%sigma%grid%zEdge
        nz = size(z)
        !
        allocate( interfaceDepth( nlayer ) )
        interfaceDepth = R_ZERO
        !
        do i = 2,nlayer
           interfaceDepth(i) = interfaceDepth(i-1)+h(i-1)
        enddo
        !>    assign layer index for each depth z(i)
        do i = 1, nz
            layerInd = 0
            do j = nlayer, 1, -1
                if(interfaceDepth(j).lt.z(i)) then 
                   !>    this should be deepest interface above z(i)
                   layerInd = j
                   exit
                endif
            enddo
            if( layerInd .GT. 0 ) then
                zLayer = z(i)-interFaceDepth(layerInd)
            else
                zLayer = z(i)
            endif
            if( layerInd .GT. 0) then
                !> downgoing and upgoing coeffcients for this layer
                d = b(2*layerInd-1)
                if(layerInd .lt. nlayer) then
                   u = b(2*layerInd)
                else
                   u = C_ZERO
                endif
                E1D(i) =  d*exp(-beta(layerInd)*zLayer)+ &
                  u*exp(beta(layerInd)*zLayer)
            else  !>  this z is in the air -- user linear expression
                E1D(i) = C_ONE + beta(1)*(b(2)-b(1))*z(i)
            endif
        enddo
        !
        deallocate( z )
        !
        deallocate( interfaceDepth )
        !
        scaleFactor = C_ONE / E1D(1)
        E1D(:) = E1D(:) * scaleFactor
        !
    end subroutine gridedSolutionForward1D

end Module Forward1D
