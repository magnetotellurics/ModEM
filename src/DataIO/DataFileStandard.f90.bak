!
!> Derived lass to read a data file and create an array with all data entries(lines)
!
module DataFileStandard
    !
    use DataFile
    !
    type, extends( DataFile_t ) :: DataFileStandard_t
        !
        !> No derived properties
        !
    contains
        !
        final :: DataFileStandard_dtor
        !
    end type DataFileStandard_t
    !
    interface DataFileStandard_t
        module procedure DataFileStandard_ctor
    end interface DataFileStandard_t
    !
contains
    !
    !> Procedure DataFileStandard_ctor
    !> Read line by line of the data file, create Data Entry objects (MT, MT_REF or CSEM)
    function DataFileStandard_ctor( funit, fname ) result( self )
        implicit none
        !
        integer, intent( in ) :: funit
        character(:), allocatable, intent( in ) :: fname
        !
        type( DataFileStandard_t ) :: self
        !
        character(len=1000) :: full_line_text
        character(len=200), dimension(20) :: args
        !
        character(:), allocatable :: line_text, actual_type, code, code_ref, component, dipole
        integer :: iDe, io_stat, p_nargs, n_tx, n_rx
        integer :: header_counter, header_line_counter, mt_counter, csem_counter
        real( kind=prec ) :: period, rvalue, imaginary, error
        real( kind=prec ) :: xyz_ref(3), latitude_ref, longitude_ref
        real( kind=prec ) :: latitude, longitude, xyz(3), tx_xyz(3)
        real( kind=prec ) :: moment, tx_azimuth, dip, azimuth
        !
        class( DataEntry_t ), allocatable :: data_entry
        !
        !write( *, * ) "Constructor DataFileStandard_t"
        !
        call self%init
        !
        self%file_name = fname
        !
        call Compact( fname )
        !
        open( unit = funit, file = fname, iostat = io_stat, status = "old" )
        !
        if( io_stat == 0 ) then
            !
            header_counter = 0
            header_line_counter = 0
            mt_counter = 0
            csem_counter = 0
            !
            do
                read( funit, "(a)", END = 10 ) full_line_text
                line_text = adjustl( full_line_text )
                line_text = trim( line_text )
                !
                call Parse( line_text, " ", args, p_nargs )
                !
                if( index( line_text, "#" ) == 0 .AND. index( line_text, ">" ) == 0 ) then
                     !
                     iDe = size( self%data_entries ) + 1
                     !
                     selectcase( actual_type )
                          !
                          !> MT file line
                          case( "Full_Impedance", "Off_Diagonal_Impedance", "Full_Vertical_Components", &
                          "Off_Diagonal_Rho_Phase", "Phase_Tensor" )
                                !
                                !# Period(s) Code GG_Lat GG_Lon X(m) Y(m) Z(m) Component Real Imag Error
                                !
                                read( args(1), * )  period
                                code = trim( args(2) )
                                read( args(3), * )  latitude
                                read( args(4), * )  longitude
                                read( args(5), * )  xyz(1)
                                read( args(6), * )  xyz(2)
                                read( args(7), * )  xyz(3)
                                component = trim( args(8) )
                                read( args(9), * )  rvalue
                                read( args(10), * ) imaginary
                                read( args(11), * ) error
                                !
                                data_entry = DataEntryMT_t( iDe, actual_type, period, code, &
                                latitude, longitude, xyz, component, rvalue, imaginary, error )
                                !
                                data_entry%is_complex = .TRUE.
                                !
                                call self%loadReceiversAndTransmitters( data_entry )
                                !
                                mt_counter = mt_counter + 1
                                !
                          !> MT REF file line
                          case( "Full_Interstation_TF" )
                                !
                                !# Period(s) Code GG_Lat GG_Lon X(m) Y(m) Z(m) Code_REF GG_Lat_REF GG_Lon_REF X(m)_REF Y(m)_REF Z(m)_REF Component Real Imag Error
                                !
                                read( args(1), * )  period
                                code = trim( args(2) )
                                read( args(3), * )  latitude
                                read( args(4), * )  longitude
                                read( args(5), * )  xyz(1)
                                read( args(6), * )  xyz(2)
                                read( args(7), * )  xyz(3)
                                code_ref = trim( args(8) )
                                read( args(9), * )  latitude_ref
                                read( args(10), * ) longitude_ref
                                read( args(11), * ) xyz_ref(1)
                                read( args(12), * ) xyz_ref(2)
                                read( args(13), * ) xyz_ref(3)
                                component = trim( args(14) )
                                read( args(15), * ) rvalue
                                read( args(16), * ) imaginary
                                read( args(17), * ) error
                                !
                                data_entry = DataEntryMT_REF_t( iDe, actual_type,    &
                                period, code, latitude, longitude, xyz, code_ref,    &
                                latitude_ref, longitude_ref, xyz_ref, component, rvalue, imaginary, error )
                                !
                                data_entry%is_complex = .TRUE.
                                !
                                call self%loadReceiversAndTransmitters( data_entry )
                                !
                                mt_counter = mt_counter + 1
                                !
                          !> SingleField file line
                          case( "Ex_Field", "Ey_Field", "Bx_Field", "By_Field", "Bz_Field" )
                                !
                                !# Dipole Period(s) Moment(Am) Azi Dip Tx_X(m) Tx_Y(x) Tx_Z(m) Code X(m) Y(x) Z(m) Component Real Imag, Error
                                !
                                dipole = args(1)
                                read( args(2), * ) period
                                read( args(3), * ) moment
                                read( args(4), * ) tx_azimuth
                                read( args(5), * ) dip
                                read( args(6), * ) tx_xyz(1)
                                read( args(7), * ) tx_xyz(2)
                                read( args(8), * ) tx_xyz(3)
                                code = trim( args(9) )
                                read( args(10), * ) xyz(1)
                                read( args(11), * ) xyz(2)
                                read( args(12), * ) xyz(3)
                                component = trim( args(13) )
                                read( args(14), * ) rvalue
                                read( args(15), * ) imaginary
                                read( args(16), * ) error
                                !
                                data_entry = DataEntryCSEM_t( iDe, actual_type,    &
                                dipole, period, moment, tx_azimuth, dip, tx_xyz,    &
                                code, xyz, component, rvalue, imaginary, error )
                                !
                                data_entry%is_complex = .TRUE.
                                !
                                call self%loadReceiversAndTransmitters( data_entry )
                                !
                                csem_counter = csem_counter + 1
                                !
                          !> Exy_Ampli_Phase file line
                          case( "Exy_Ampli_Phase" )
                                !
                                !# Dipole Period(s) Moment(Am) Azi Dip Tx_X(m) Tx_Y(x) Tx_Z(m) Code X(m) Y(x) Z(m) Component Ampli Error tx_azimuth
                                !
                                dipole = args(1)
                                read( args(2), * ) period
                                read( args(3), * ) moment
                                read( args(4), * ) tx_azimuth
                                read( args(5), * ) dip
                                read( args(6), * ) tx_xyz(1)
                                read( args(7), * ) tx_xyz(2)
                                read( args(8), * ) tx_xyz(3)
                                code = trim( args(9) )
                                read( args(10), * ) xyz(1)
                                read( args(11), * ) xyz(2)
                                read( args(12), * ) xyz(3)
                                component = trim( args(13) )
                                read( args(14), * ) rvalue
                                read( args(15), * ) error
                                read( args(16), * ) azimuth
                                !
                                data_entry = DataEntryCSEM_t( iDe, actual_type,    &
                                dipole, period, moment, tx_azimuth, dip, tx_xyz,    &
                                code, xyz, component, rvalue, R_ZERO, error, azimuth )
                                !
                                data_entry%is_complex = .FALSE.
                                !
                                call self%loadReceiversAndTransmitters( data_entry )
                                !
                                csem_counter = csem_counter + 1
                                !
                          case default
                                !
                                write( *, * ) "Unknown type :[", actual_type, "]"
                                stop "DataFileStandard.f08: DataFileStandard_ctor()"
                                !
                     end select
                     !
                     header_line_counter = 0
                     !
                else
                     !# Synthetic 3D MT data written in Matlab
                     !# Period(s) Code GG_Lat GG_Lon X(m) Y(m) Z(m) Component Real Imag Error
                     !> Full_Impedance
                     !> exp(-i\omega t)
                     !> [V/m]/[T]
                     !> 0.00
                     !> 0.000 0.000
                     !> 4 2
                     header_line_counter = header_line_counter + 1
                     selectcase( header_line_counter )
                         !
                         !> Main Header, Data Fields
                         case( 1, 2 )
                         !
                         !> Data Type
                         case( 3 )
                             !
                             actual_type = args(2)
                         !
                         !> exp(-i\omega t)
                         case( 4 )
                            !
                            conjugated_data = ( index( args(2), "+" ) > 0 )
                            !
                         !
                         !> Units: [V/m]/[T], []
                         case( 5 )
                            !
                            units_in_file = trim( args(2) )
                            !
                         !> geographic_orientation
                         case( 6 )
                            !
                            read( args(2), * ) self%geographic_orientation
                            !
                         !> Origin in file [x,y]
                         case( 7 )
                             !
                             read( args(2), * ) self%origin(1)
                             read( args(3), * ) self%origin(2)
                             !
                         !> n_tx, n_rx
                         case( 8 )
                             !
                             read( args(2), * ) n_tx
                             read( args(3), * ) n_rx
                             !
                             header_counter = header_counter + 1
                             write( *, "(A17, I8, A5, A20, A2, A15, A3, I8, A9, I8, A5)" ) "Header", header_counter, " -> (", trim(actual_type), ", ", trim(units_in_file( size( units_in_file ) )%str), "): ", n_tx, " Txs and ", n_rx, " Rxs."
                             !
                             self%n_rx = self%n_rx + n_rx
                             self%n_tx = self%n_tx + n_tx
                             !
                         case default
                             !
                             write( *, * ) "Unknown header format in line :[", header_line_counter, "]"
                             stop "DataFileStandard.f08: DataFileStandard_ctor()"
                             !
                     end select
                     !
                endif
                !
            enddo
            !
10          close( unit = funit )
            !
            ! Verbose
            !write( *, * ) "          ", trim( self%units ), " to ", trim( units_in_file ), " => ", self%SI_factor
            !
            if( mt_counter > 0 )   write( *, * ) "          Read ", mt_counter,   " MT Entries"
            if( csem_counter > 0 ) write( *, * ) "          Read ", csem_counter, " CSEM Entries"
            !
            call self%contructMeasuredDataGroupTxArray()
            !
        else
            write( *, * ) "Error opening [", fname, "] in DataFileStandard_ctor"
            stop
        endif
        !
    end function DataFileStandard_ctor
    !
    !> Dynamically add a new DataGroupTx to the array, always via reallocation.
    !
    subroutine updateFileUnitsArray( file_units_array, str_file_unit )
        implicit none
        !
        type( String_t ), allocatable, dimension(:), intent( inout ) :: file_units_array
        character(*), intent( in ) :: str_file_unit
        !
        integer :: n_dtx
        type( String_t ), allocatable, dimension(:) :: temp_array
        !
        if( .NOT. allocated( file_units_array ) ) then
            !
            allocate( file_units_array(1) )
            !
            file_units_array(1)%str = str_file_unit
            !
        else
            !
            n_dtx = size( file_units_array )
            !
            allocate( temp_array( n_dtx + 1 ) )
            !
            temp_array( 1 : n_dtx ) = file_units_array(:)
            !
            temp_array( n_dtx + 1 )%str = str_file_unit
            !
            deallocate( file_units_array )
            !
            allocate( file_units_array, source = temp_array )
            !
            deallocate( temp_array )
            !
        endif
        !
    end subroutine updateFileUnitsArray
    !
    !> No subroutine briefing
    subroutine DataFileStandard_dtor( self )
        implicit none
        !
        type( DataFileStandard_t ), intent( inout ) :: self
        !
        !write( *, * ) "Destructor DataFileStandard_t"
        !
        call self%dealloc
        !
    end subroutine DataFileStandard_dtor
    !
end module DataFileStandard
