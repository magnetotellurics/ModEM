!------------------------------------------------------------
!>  FD EM subroutine reflectivity
!
!>  computes 3D EM wavefields at given positions for 1D models using the reflectivity method
!>  can be used for fields at grid points (staggered and non-staggered), receivers and individual points
!>    by defining coordinate vectors accordingly
!>  different coordinates can be used for different field components
!
!>  equations based on Loeseth and Ursin 2007
!>  sign conventions as in Loeseth and Ursin 2007
!
!>  CAUTION:
!>      With increasing distance from the source, integrands of Bessel function integrals
!>      become larger than the integration results by many orders of magnitude. As a 
!>      general rule, the code will fail if the true integrated values are more than 15
!>      orders of magnitude smaller than the maximum of the integrand functions. To compute
!>      such integrals, an extended (quadruple) precision version could be used, but 
!>      quadruple precision is SLOW, and then the accuracy will be limited by the 20-digit
!>      precision of the integration weights in BESQUD.
!
!>  Rita Streich 2009-2011
!
!------------------------------------------------------------
subroutine reflectivity_unified(src,bgdat,refl_var,ifreq,icur,comm)

  implicit none

  !external variables
  type(sorec) :: src        !a single source
  type(backgrounddata) :: bgdat      !coordinate vectors and output EM fields
  type(refl_struct) :: refl_var   !all variables that have to be remembered while computing 1D fields
  integer(kind=int32) :: ifreq      !index of frequency component
  integer(kind=int32) :: icur       !source current counter
  integer(kind=int32),intent( in ) :: comm     !MPI communicator

  !internal variables
  real(kind=real64),dimension(:),pointer :: zbound  !depths of layer boundaries
  integer(kind=int32) :: dowhat      !what to compute: fields or sensitivities or both
  integer(kind=int32) :: ierr        !error index
  real(kind=real64) :: ommu,ommusq !omega times mu0 (strictly: in receiver layer, but mu0 is constant everywhere)
  integer(kind=int32) :: izsrc,izrec      !counter for source and receiver depths
  real(kind=real64) :: sz          !source depth
  real(kind=real64) :: zr          !receiver depth
  complex(kind=real64) :: omeps_srcv  !omega times epsilon in source layer
  complex(kind=real64) :: omeps_recv  !omeps in "receiver layer"
  integer(kind=int32) :: ilay        !layer counter for derivatives



  !some initialization...
  zbound => bgdat%zbound
  nlay = bgdat%nlay
  dowhat = bgdat%dowhat
  aniso = bgdat%aniso
  rsplmin = bgdat%rsplmin

  !initialize fields to zero for the entire source
  if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
    bgdat%Ex = 0._real64
    bgdat%Ey = 0._real64
    bgdat%Ez = 0._real64
    if(bgdat%nHx .gt.0 ) then
    bgdat%Hx = 0._real64
    bgdat%Hy = 0._real64
    bgdat%Hz = 0._real64
    endif
  endif
  if(dowhat.ge.deriv) then
    bgdat%dExdm = 0._real64
    bgdat%dEydm = 0._real64
    bgdat%dEzdm = 0._real64
    if(bgdat%nHx .gt.0 ) then
    bgdat%dHxdm = 0._real64
    bgdat%dHydm = 0._real64
    bgdat%dHzdm = 0._real64
    endif
    if(aniso .EQ. vti) then
      bgdat%dExdmv = 0._real64
      bgdat%dEydmv = 0._real64
      bgdat%dEzdmv = 0._real64
      if(bgdat%nHx .gt.0 ) then
      bgdat%dHxdmv = 0._real64
      bgdat%dHydmv = 0._real64
      bgdat%dHzdmv = 0._real64
      endif
    endif
  endif


!-----------------------------------------------------------------
!> prepare vectors for medium properties
!-----------------------------------------------------------------

  !complex medium parameters
  allocate(epsv(nlay),epsh(nlay),epsmuv(nlay),epsmuh(nlay),epsmuratio(nlay),omsq_epsmuv(nlay),omsq_epsmuh(nlay), stat=ierr)
  if(ierr.NE.0) call alloc_error(pid,'reflectivity','eps, epsmu',ierr)

  !vertical wavenumbers -> allocation not needed because they point to another array
!!$  allocate(pvert(nlay),stat=ierr)
!!$  if(ierr.NE.0) call alloc_error(pid,'reflectivity','pvert',ierr)

  !branch points
  allocate(branchpt(2*nlay), stat=ierr)
  if(ierr.NE.0) call alloc_error(pid,'reflectivity','branchpoint vector',ierr)


  !medium property vectors
  omega = bgdat%omega
  omegasq = omega**2
  ommu = omega * dmu0
  ommusq = ommu**2
  jomega = dci*omega
  j_om_mu = jomega * dmu0

  epsh = bgdat%epsrh*deps0 + dci*bgdat%sigh/omega
  epsv = bgdat%epsrv*deps0 + dci*bgdat%sigv/omega
  epsmuv = epsv*dmu0
  epsmuh = epsh*dmu0
  epsmuratio = epsmuh / epsmuv
  omsq_epsmuv = omegasq*epsmuv
  omsq_epsmuh = omegasq*epsmuh

  !branchpoints (only used for adaptive integration and not really meaningful at low freqs but VERY important at high freqs)
  branchpt(1:nlay) = real(-jomega*epsmuh)
  branchpt(nlay+1:2*nlay) = real(-jomega*epsmuv)
  call sort_dbl(2*nlay,branchpt)

  !initialize interface reflection coeff. matrices and vectors
  call init_refcoef()


  !find all depths at which to compute fields
  !this is independent of source type!
  call find_recdepths_general(bgdat,refl_var)

  !get minimum and maximum radii
  !global values can be used for ALL numerical integrations without creating overhead, 
  !search is simplified if the same coordinates are used for all field components and/or receiver depths
  call find_radii_global(refl_var,src,bgdat,comm)


  !work arrays for numerical integration: allocate for max. number of integrals that may ever be needed - overhead is negligible
  call init_intval(refl_var,bgdat)


  !-----------------------------------------------------------------
  !> distinguish between source types
  !-----------------------------------------------------------------
  sourcetype: select case (src%type)
  !-----------------------------------------------------------------
  !> dipole sources
  !-----------------------------------------------------------------
  case (dipole)

    !***********************************************************************
    !>  HED components
    !***********************************************************************

    !get unique source element depths into refl_var structure
    call find_srcdepths(src,refl_var,hed)

    !if there are any HED components, compute fields for them
    if(refl_var%nzsrc .gt. 0) then
      !loop over source depths
      !> have this outside because layer thicknesses for receiver are relative to source depth...
      srczloophed: do izsrc = 1,refl_var%nzsrc

        call prepare_srcdepth(sz,omeps_srcv,refl_var,src,izsrc,zbound,omega)

        !if all field components are to be computed at the same coordinates, use routines that combine evaluation of all components
        !this is more efficient than separate evaluation: e.g. radii/angles have to be computed only once, related integrals can be used
        samecoord_hed: if(bgdat%allcomp_samecoord) then

          !loop over receiver depths
          recdepthshed_all: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,hed)

              hedfwd: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then

                !precompute integral values and spline derivatives
                call precomp_intvals_hed(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hed_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,bgdat%Ez, &
                    bgdat%Hx,bgdat%Hy,bgdat%Hz, omeps_recv,ommu, &
                    iabvA0TE,iabvA0TM,iabvA1TE,iabvA1TM,iabvDz1TM,iabvD0TE,iabvD0TM,iabvD1TE,iabvD1TM,iabvAz1TE,0) !zero for ilay
                else
                  call interp_intvals_hed_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,bgdat%Ez, &
                    bgdat%Hx,bgdat%Hy,bgdat%Hz, omeps_recv,ommu, &
                    iblwA0TE,iblwA0TM,iblwA1TE,iblwA1TM,iblwDz1TM,iblwD0TE,iblwD0TM,iblwD1TE,iblwD1TM,iblwAz1TE,0)
                endif
              endif hedfwd
              hedderiv: if(dowhat .ge. deriv) then

                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hed,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hed(refl_var,sz,zr,ilay,iabvA0TEderiv,iabvA0TMderiv,iabvA1TEderiv, &
                        iabvA1TMderiv,iabvDz1TMderiv,iabvD0TEderiv,iabvD0TMderiv,iabvD1TEderiv,iabvD1TMderiv, &
                        iabvAz1TEderiv,iabvDz1TM)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hed_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay), omeps_recv,ommu, &
                        iabvA0TEderiv,iabvA0TMderiv,iabvA1TEderiv,iabvA1TMderiv,iabvDz1TMderiv,iabvD0TEderiv,iabvD0TMderiv, &
                        iabvD1TEderiv,iabvD1TMderiv,iabvAz1TEderiv,ilay,iabvDz1TM)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed(refl_var,sz,zr,ilay,iabvA0TEderiv,iabvA0TMderivh,iabvA1TEderiv, &
                        iabvA1TMderivh,iabvDz1TMderivh,iabvD0TEderiv,iabvD0TMderivh,iabvD1TEderiv,iabvD1TMderivh, &
                        iabvAz1TEderiv,iabvDz1TM, &
                        iabvA0TMderivv,iabvA1TMderivv,iabvDz1TMderivv,iabvD0TMderivv,iabvD1TMderivv)
                      call interp_intvals_hed_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_recv,ommu, &
                        iabvA0TEderiv,iabvA0TMderivh,iabvA1TEderiv,iabvA1TMderivh,iabvDz1TMderivh,iabvD0TEderiv,iabvD0TMderivh, &
                        iabvD1TEderiv,iabvD1TMderivh,iabvAz1TEderiv,ilay,iabvDz1TM, &
                        iabvA0TMderivv,iabvA1TMderivv,iabvDz1TMderivv,iabvD0TMderivv,iabvD1TMderivv, &
                        bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay),bgdat%dEzdmv(:,ilay),bgdat%dHxdmv(:,ilay), &
                        bgdat%dHydmv(:,ilay),bgdat%dHzdmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      call precomp_intvals_deriv_hed(refl_var,sz,zr,ilay,iblwA0TEderiv,iblwA0TMderiv,iblwA1TEderiv, &
                        iblwA1TMderiv,iblwDz1TMderiv,iblwD0TEderiv,iblwD0TMderiv,iblwD1TEderiv,iblwD1TMderiv, &
                        iblwAz1TEderiv,iblwDz1TM)
                      call interp_intvals_hed_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay), omeps_recv,ommu, &
                        iblwA0TEderiv,iblwA0TMderiv,iblwA1TEderiv,iblwA1TMderiv,iblwDz1TMderiv,iblwD0TEderiv,iblwD0TMderiv, &
                        iblwD1TEderiv,iblwD1TMderiv,iblwAz1TEderiv,ilay,iblwDz1TM)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed(refl_var,sz,zr,ilay,iblwA0TEderiv,iblwA0TMderivh,iblwA1TEderiv, &
                        iblwA1TMderivh,iblwDz1TMderivh,iblwD0TEderiv,iblwD0TMderivh,iblwD1TEderiv,iblwD1TMderivh, &
                        iblwAz1TEderiv,iblwDz1TM, &
                        iblwA0TMderivv,iblwA1TMderivv,iblwDz1TMderivv,iblwD0TMderivv,iblwD1TMderivv)
                      call interp_intvals_hed_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay), omeps_recv,ommu, &
                        iblwA0TEderiv,iblwA0TMderivh,iblwA1TEderiv,iblwA1TMderivh,iblwDz1TMderivh,iblwD0TEderiv,iblwD0TMderivh, &
                        iblwD1TEderiv,iblwD1TMderivh,iblwAz1TEderiv,ilay,iblwDz1TM, &
                        iblwA0TMderivv,iblwA1TMderivv,iblwDz1TMderivv,iblwD0TMderivv,iblwD1TMderivv, &
                        bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay),bgdat%dEzdmv(:,ilay),bgdat%dHxdmv(:,ilay), &
                        bgdat%dHydmv(:,ilay),bgdat%dHzdmv(:,ilay))
                    endif
                  endif
                enddo
              endif hedderiv

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshed_all !loop over receiver depths

        else

          !----- Ex and/or Ey ----------------------------
          !loop over receiver depths
          recdepthshedExy: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,hed)

              hedfwdExy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Exy_hed(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hed_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,  &
                    iabvA0TE,iabvA0TM,iabvA1TE,iabvA1TM, 0) !zero for ilay
                else
                  call interp_intvals_hed_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,  &
                    iblwA0TE,iblwA0TM,iblwA1TE,iblwA1TM, 0)
                endif
              endif hedfwdExy
              hedderivExy: if(dowhat .ge. deriv) then

                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hed,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hed_Exy(refl_var,sz,zr,ilay,iabvA0TEderiv,iabvA0TMderiv,iabvA1TEderiv, &
                        iabvA1TMderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hed_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        iabvA0TEderiv,iabvA0TMderiv,iabvA1TEderiv,iabvA1TMderiv,ilay)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Exy(refl_var,sz,zr,ilay,iabvA0TEderiv,iabvA0TMderivh,iabvA1TEderiv, &
                        iabvA1TMderivh, &
                        iabvA0TMderivv,iabvA1TMderivv)
                      call interp_intvals_hed_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        iabvA0TEderiv,iabvA0TMderivh,iabvA1TEderiv,iabvA1TMderivh,ilay, &
                        iabvA0TMderivv,iabvA1TMderivv, &
                        bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      call precomp_intvals_deriv_hed_Exy(refl_var,sz,zr,ilay,iblwA0TEderiv,iblwA0TMderiv,iblwA1TEderiv, &
                        iblwA1TMderiv)
                      call interp_intvals_hed_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        iblwA0TEderiv,iblwA0TMderiv,iblwA1TEderiv,iblwA1TMderiv,ilay)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Exy(refl_var,sz,zr,ilay,iblwA0TEderiv,iblwA0TMderivh,iblwA1TEderiv, &
                        iblwA1TMderivh, &
                        iblwA0TMderivv,iblwA1TMderivv)
                      call interp_intvals_hed_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        iblwA0TEderiv,iblwA0TMderivh,iblwA1TEderiv,iblwA1TMderivh,ilay, &
                        iblwA0TMderivv,iblwA1TMderivv, &
                        bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay))
                    endif
                  endif
                enddo
              endif hedderivExy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshedExy !loop over receiver depths

          !----- Ez ----------------------------
          !loop over receiver depths
          recdepthshedEz: do izrec = 1,refl_var%nzrecEz
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecEz,refl_var%nrecperzEz,izrec,sz,zbound,aniso,omega,hed)

              hedfwdEz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then

                !precompute integral values and spline derivatives
                call precomp_intvals_Ez_hed(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hed_Ez(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ez, &
                     omeps_recv, iabvDz1TM, 0) !zero for ilay
                else
                  call interp_intvals_hed_Ez(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ez, &
                     omeps_recv, iblwDz1TM, 0)
                endif
              endif hedfwdEz
              hedderivEz: if(dowhat .ge. deriv) then

                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hed,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hed_Ez(refl_var,sz,zr,ilay,iabvDz1TMderiv,iabvDz1TM)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hed_Ez(refl_var,src,ifreq,sz,zr,bgdat, &
                        bgdat%dEzdm(:,ilay), omeps_recv, iabvDz1TMderiv, ilay,iabvDz1TM)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Ez(refl_var,sz,zr,ilay,iabvDz1TMderivh,iabvDz1TM, &
                        iabvDz1TMderivv)
                      call interp_intvals_hed_Ez(refl_var,src,ifreq,sz,zr,bgdat, &
                        bgdat%dEzdm(:,ilay),omeps_recv, iabvDz1TMderivh,ilay,iabvDz1TM, &
                        iabvDz1TMderivv, bgdat%dEzdmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      call precomp_intvals_deriv_hed_Ez(refl_var,sz,zr,ilay,iblwDz1TMderiv,iblwDz1TM)
                      call interp_intvals_hed_Ez(refl_var,src,ifreq,sz,zr,bgdat, &
                        bgdat%dEzdm(:,ilay), omeps_recv, iblwDz1TMderiv,ilay,iblwDz1TM)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Ez(refl_var,sz,zr,ilay,iblwDz1TMderivh,iblwDz1TM, &
                        iblwDz1TMderivv)
                      call interp_intvals_hed_Ez(refl_var,src,ifreq,sz,zr,bgdat, &
                        bgdat%dEzdm(:,ilay), omeps_recv, iblwDz1TMderivh,ilay,iblwDz1TM, &
                        iblwDz1TMderivv, bgdat%dEzdmv(:,ilay))
                    endif
                  endif
                enddo
              endif hedderivEz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshedEz !loop over receiver depths

          !----- Hx and / or Hy ----------------------------
          !loop over receiver depths
          recdepthshed_Hxy: do izrec = 1,refl_var%nzrecHxy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHxy,refl_var%nrecperzHxy,izrec,sz,zbound,aniso,omega,hed)

              hedfwdHxy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then

                !precompute integral values and spline derivatives
                call precomp_intvals_Hxy_hed(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hed_Hxy(refl_var,src,ifreq,sz,zr,bgdat, &
                    bgdat%Hx,bgdat%Hy, iabvD0TE,iabvD0TM,iabvD1TE,iabvD1TM,0) !zero for ilay
                else
                  call interp_intvals_hed_Hxy(refl_var,src,ifreq,sz,zr,bgdat, &
                    bgdat%Hx,bgdat%Hy, iblwD0TE,iblwD0TM,iblwD1TE,iblwD1TM,0)
                endif
              endif hedfwdHxy
              hedderivHxy: if(dowhat .ge. deriv) then

                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hed,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hed_Hxy(refl_var,sz,zr,ilay,iabvD0TEderiv,iabvD0TMderiv,iabvD1TEderiv, &
                        iabvD1TMderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hed_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),  &
                        iabvD0TEderiv,iabvD0TMderiv, iabvD1TEderiv,iabvD1TMderiv,ilay)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Hxy(refl_var,sz,zr,ilay,iabvD0TEderiv,iabvD0TMderivh,iabvD1TEderiv, &
                         iabvD1TMderivh, iabvD0TMderivv,iabvD1TMderivv)
                      call interp_intvals_hed_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        iabvD0TEderiv,iabvD0TMderivh,iabvD1TEderiv,iabvD1TMderivh,ilay, &
                        iabvD0TMderivv,iabvD1TMderivv, bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      call precomp_intvals_deriv_hed_Hxy(refl_var,sz,zr,ilay,iblwD0TEderiv,iblwD0TMderiv,iblwD1TEderiv, &
                        iblwD1TMderiv)
                      call interp_intvals_hed_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        iblwD0TEderiv,iblwD0TMderiv, iblwD1TEderiv,iblwD1TMderiv,ilay)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Hxy(refl_var,sz,zr,ilay,iblwD0TEderiv,iblwD0TMderivh,iblwD1TEderiv, &
                        iblwD1TMderivh, iblwD0TMderivv,iblwD1TMderivv)
                      call interp_intvals_hed_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        iblwD0TEderiv,iblwD0TMderivh,iblwD1TEderiv,iblwD1TMderivh,ilay, &
                        iblwD0TMderivv,iblwD1TMderivv, bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay))
                    endif
                  endif
                enddo
              endif hedderivHxy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshed_Hxy !loop over receiver depths

          !----- Hz ----------------------------
          !loop over receiver depths
          recdepthshed_Hz: do izrec = 1,refl_var%nzrecHz
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHz,refl_var%nrecperzHz,izrec,sz,zbound,aniso,omega,hed)

              hedfwdHz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then

                !precompute integral values and spline derivatives
                call precomp_intvals_Hz_hed(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hed_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hz, ommu, iabvAz1TE,0) !zero for ilay
                else
                  call interp_intvals_hed_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hz, ommu, iblwAz1TE,0)
                endif
              endif hedfwdHz
              hedderivHz: if(dowhat .ge. deriv) then

                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hed,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hed_Hz(refl_var,sz,zr,ilay, iabvAz1TEderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hed_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay), ommu, iabvAz1TEderiv,ilay)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Hz(refl_var,sz,zr,ilay, iabvAz1TEderiv)
                      call interp_intvals_hed_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay), ommu, iabvAz1TEderiv,ilay)
                    endif
                  else
                    if(aniso.EQ.iso) then
                      call precomp_intvals_deriv_hed_Hz(refl_var,sz,zr,ilay,iblwAz1TEderiv)
                      call interp_intvals_hed_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay), ommu, iblwAz1TEderiv,ilay)
                    else
                      !vti: also input TM derivative integrals for epsv
                      call precomp_intvals_deriv_hed_Hz(refl_var,sz,zr,ilay,iblwAz1TEderiv)
                      call interp_intvals_hed_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay), ommu, iblwAz1TEderiv,ilay)
                    endif
                  endif
                enddo
              endif hedderivHz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshed_Hz !loop over receiver depths

        endif samecoord_hed  !same coordinates for all field components?

        deallocate(refl_var%xs,refl_var%ys, stat=ierr)
        deallocate(trans_above_src,trans_below_src,dz_above_src,dz_below_src, stat=ierr)

      enddo srczloophed !unique source element depths

      deallocate(refl_var%isrcperz,refl_var%zsrc,refl_var%nsrcperz,refl_var%betasrc, stat=ierr)

    endif


    !***********************************************************************
    !>  VED components
    !***********************************************************************

    !get unique source element depths into refl_var structure
    call find_srcdepths(src,refl_var,ved)

    !if there are any VED components, compute fields for them
    if(refl_var%nzsrc .gt. 0) then
      !loop over source depths
      srczloopved: do izsrc = 1,refl_var%nzsrc

        call prepare_srcdepth(sz,omeps_srcv,refl_var,src,izsrc,zbound,omega)

        !same coordinates for all field components?
        samecoord_ved: if(bgdat%allcomp_samecoord) then

          !loop over receiver depths
          recdepthsved_all: do izrec = 1,refl_var%nzrecExy
          call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,ved)

              vedfwd: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_ved(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_ved_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,bgdat%Ez, &
                    bgdat%Hx,bgdat%Hy,bgdat%Hz,omeps_srcv,omeps_recv, iabvB1TMved,iabvC0TMved,iabvC1TMved,0)
                else
                  call interp_intvals_ved_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,bgdat%Ez, &
                    bgdat%Hx,bgdat%Hy,bgdat%Hz,omeps_srcv,omeps_recv, iblwB1TMved,iblwC0TMved,iblwC1TMved,0)
                endif
              endif vedfwd
              vedderiv: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,ved,aniso)

                  !get derivatives of field values at receiver points
                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved(refl_var,sz,zr,ilay, &
                        iabvB1TMvedderiv,iabvC0TMvedderiv,iabvCz1TMderiv,iabvB1TMved,iabvC0TMved,iabvC1TMved)

                      call interp_intvals_ved_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iabvB1TMvedderiv,iabvC0TMvedderiv,iabvCz1TMderiv,ilay,iabvB1TMved,iabvC0TMved,iabvC1TMved)
                    else
                      call precomp_intvals_deriv_ved(refl_var,sz,zr,ilay, &
                      iabvB1TMvedderivh,iabvC0TMvedderivh,iabvCz1TMderivh,iabvB1TMved,iabvC0TMved,iabvC1TMved, &
                      iabvB1TMvedderivv,iabvC0TMvedderivv,iabvCz1TMderivv)

                      call interp_intvals_ved_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iabvB1TMvedderivh,iabvC0TMvedderivh,iabvCz1TMderivh,ilay,iabvB1TMved,iabvC0TMved,iabvC1TMved, &
                        iabvB1TMvedderivv,iabvC0TMvedderivv,iabvCz1TMderivv,bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay), &
                        bgdat%dEzdmv(:,ilay),bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay),bgdat%dHzdmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved(refl_var,sz,zr,ilay, &
                        iblwB1TMvedderiv,iblwC0TMvedderiv,iblwCz1TMderiv,iblwB1TMved,iblwC0TMved,iblwC1TMved)

                      call interp_intvals_ved_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iblwB1TMvedderiv,iblwC0TMvedderiv,iblwCz1TMderiv,ilay,iblwB1TMved,iblwC0TMved,iblwC1TMved)
                    else
                      call precomp_intvals_deriv_ved(refl_var,sz,zr,ilay, &
                      iblwB1TMvedderivh,iblwC0TMvedderivh,iblwCz1TMderivh,iblwB1TMved,iblwC0TMved,iblwC1TMved, &
                      iblwB1TMvedderivv,iblwC0TMvedderivv,iblwCz1TMderivv)

                      call interp_intvals_ved_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iblwB1TMvedderivh,iblwC0TMvedderivh,iblwCz1TMderivh,ilay,iblwB1TMved,iblwC0TMved,iblwC1TMved, &
                        iblwB1TMvedderivv,iblwC0TMvedderivv,iblwCz1TMderivv,bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay), &
                        bgdat%dEzdmv(:,ilay),bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay),bgdat%dHzdmv(:,ilay))
                    endif
                  endif
                enddo
              endif vedderiv

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsved_all !loop over receiver depths

        else

          !> ---- Ex and / or Ey ----------------
          !loop over receiver depths
          recdepthsvedExy: do izrec = 1,refl_var%nzrecExy
          call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,ved)

              vedfwdExy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Exy_ved(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_ved_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,omeps_srcv, iabvB1TMved,0)
                else
                  call interp_intvals_ved_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,omeps_srcv, iblwB1TMved,0)
                endif
              endif vedfwdExy
              vedderivExy: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,ved,aniso)

                  !get derivatives of field values at receiver points
                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved_Exy(refl_var,sz,zr,ilay, iabvB1TMvedderiv,iabvB1TMved)

                      call interp_intvals_ved_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        omeps_srcv, iabvB1TMvedderiv,ilay,iabvB1TMved)
                    else
                      call precomp_intvals_deriv_ved_Exy(refl_var,sz,zr,ilay, iabvB1TMvedderivh,iabvB1TMved, iabvB1TMvedderivv)

                      call interp_intvals_ved_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        omeps_srcv, iabvB1TMvedderivh,ilay,iabvB1TMved, iabvB1TMvedderivv, &
                        bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved_Exy(refl_var,sz,zr,ilay, iblwB1TMvedderiv,iblwB1TMved)

                      call interp_intvals_ved_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        omeps_srcv, iblwB1TMvedderiv,ilay,iblwB1TMved)
                    else
                      call precomp_intvals_deriv_ved_Exy(refl_var,sz,zr,ilay, iblwB1TMvedderivh,iblwB1TMved, iblwB1TMvedderivv)

                      call interp_intvals_ved_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        omeps_srcv, iblwB1TMvedderivh,ilay,iblwB1TMved, iblwB1TMvedderivv, &
                        bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay))
                    endif
                  endif
                enddo
              endif vedderivExy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvedExy !loop over receiver depths

          !> ---- Ez ----------------
          !loop over receiver depths
          recdepthsvedEz: do izrec = 1,refl_var%nzrecEz
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecEz,refl_var%nrecperzEz,izrec,sz,zbound,aniso,omega,ved)

              vedfwdEz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Ez_ved(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_ved_Ez(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ez, omeps_srcv,omeps_recv, iabvC0TMved,0)
                else
                  call interp_intvals_ved_Ez(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ez, omeps_srcv,omeps_recv, iblwC0TMved,0)
                endif
              endif vedfwdEz
              vedderivEz: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,ved,aniso)

                  !get derivatives of field values at receiver points
                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved_Ez(refl_var,sz,zr,ilay, iabvC0TMvedderiv,iabvC0TMved)

                      call interp_intvals_ved_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iabvC0TMvedderiv,ilay,iabvC0TMved)
                    else
                      call precomp_intvals_deriv_ved_Ez(refl_var,sz,zr,ilay, iabvC0TMvedderivh,iabvC0TMved, iabvC0TMvedderivv)

                      call interp_intvals_ved_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iabvC0TMvedderivh,ilay,iabvC0TMved, iabvC0TMvedderivv, bgdat%dEzdmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved_Ez(refl_var,sz,zr,ilay, iblwC0TMvedderiv,iblwC0TMved)

                      call interp_intvals_ved_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iblwC0TMvedderiv,ilay,iblwC0TMved)
                    else
                      call precomp_intvals_deriv_ved_Ez(refl_var,sz,zr,ilay, iblwC0TMvedderivh,iblwC0TMved, iblwC0TMvedderivv)

                      call interp_intvals_ved_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_srcv,omeps_recv, &
                        iblwC0TMvedderivh,ilay,iblwC0TMved, iblwC0TMvedderivv, bgdat%dEzdmv(:,ilay))
                    endif
                  endif
                enddo
              endif vedderivEz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvedEz

          !> ---- Hx and / or Hy ----------------
          !loop over receiver depths
          recdepthsvedHxy: do izrec = 1,refl_var%nzrecHxy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHxy,refl_var%nrecperzHxy,izrec,sz,zbound,aniso,omega,ved)

              vedfwdHxy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Hxy_ved(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_ved_Hxy(refl_var,src,ifreq,sz,zr,bgdat, bgdat%Hx,bgdat%Hy,omeps_srcv, iabvC1TMved,0)
                else
                  call interp_intvals_ved_Hxy(refl_var,src,ifreq,sz,zr,bgdat, bgdat%Hx,bgdat%Hy,omeps_srcv, iblwC1TMved,0)
                endif
              endif vedfwdHxy
              vedderivHxy: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,ved,aniso)

                  !get derivatives of field values at receiver points
                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved_Hxy(refl_var,sz,zr,ilay, iabvCz1TMderiv,iabvC1TMved)

                      call interp_intvals_ved_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        omeps_srcv, iabvCz1TMderiv,ilay,iabvC1TMved)
                    else
                      call precomp_intvals_deriv_ved_Hxy(refl_var,sz,zr,ilay, iabvCz1TMderivh,iabvC1TMved, iabvCz1TMderivv)

                      call interp_intvals_ved_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        omeps_srcv, iabvCz1TMderivh,ilay,iabvC1TMved, &
                        iabvCz1TMderivv,bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_ved_Hxy(refl_var,sz,zr,ilay, iblwCz1TMderiv,iblwC1TMved)

                      call interp_intvals_ved_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        omeps_srcv, iblwCz1TMderiv,ilay,iblwC1TMved)
                    else
                      call precomp_intvals_deriv_ved_Hxy(refl_var,sz,zr,ilay, iblwCz1TMderivh,iblwC1TMved, iblwCz1TMderivv)

                      call interp_intvals_ved_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                        omeps_srcv, iblwCz1TMderivh,ilay,iblwC1TMved, &
                        iblwCz1TMderivv,bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay))
                    endif
                  endif
                enddo
              endif vedderivHxy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvedHxy !loop over receiver depths

          !no Hz for VED source

        endif samecoord_ved
        deallocate(refl_var%xs,refl_var%ys, stat=ierr)
        deallocate(trans_above_src,trans_below_src,dz_above_src,dz_below_src, stat=ierr)

      enddo srczloopved !unique source element depths

      deallocate(refl_var%isrcperz,refl_var%zsrc,refl_var%nsrcperz,refl_var%betasrc, stat=ierr)

    endif


    !***********************************************************************
    !>  HMD components
    !***********************************************************************

    !get unique source element depths into refl_var structure
    call find_srcdepths(src,refl_var,hmd)

    !if there are any HMD components, compute fields for them
    if(refl_var%nzsrc .gt. 0) then

      !loop over source depths
      srczloophmd: do izsrc = 1,refl_var%nzsrc

        call prepare_srcdepth(sz,omeps_srcv,refl_var,src,izsrc,zbound,omega)

        !same coordinates for all field components?
        samecoord_hmd: if(bgdat%allcomp_samecoord) then

          !loop over receiver depths
          recdepthshmd_all: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,hmd)

              hmdfwd: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_hmd(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey, &
                    bgdat%Ez,bgdat%Hx,bgdat%Hy,bgdat%Hz,omeps_recv,j_om_mu, &
                    iabvB0TE,iabvB0TM,iabvB1TE,iabvB1TM,iabvCz1TM,iabvC0TE,iabvC0TM,iabvC1TE,iabvC1TM,iabvBz1TE,0)
                else
                  call interp_intvals_hmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey, &
                    bgdat%Ez,bgdat%Hx,bgdat%Hy,bgdat%Hz,omeps_recv,j_om_mu, &
                    iblwB0TE,iblwB0TM,iblwB1TE,iblwB1TM,iblwCz1TM,iblwC0TE,iblwC0TM,iblwC1TE,iblwC1TM,iblwBz1TE,0)
                endif
              endif hmdfwd

              hmdderiv: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hmd,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd(refl_var,sz,zr,ilay,iabvB0TEderiv,iabvB0TMderiv,iabvB1TEderiv, &
                        iabvB1TMderiv,iabvCz1TMderiv,iabvC0TEderiv,iabvC0TMderiv,iabvC1TEderiv,iabvC1TMderiv, &
                        iabvBz1TEderiv,iabvCz1TM)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_recv,j_om_mu, &
                        iabvB0TEderiv,iabvB0TMderiv,iabvB1TEderiv,iabvB1TMderiv,iabvCz1TMderiv,iabvC0TEderiv,iabvC0TMderiv, &
                        iabvC1TEderiv,iabvC1TMderiv,iabvBz1TEderiv,ilay,iabvCz1TM)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd(refl_var,sz,zr,ilay,iabvB0TEderiv,iabvB0TMderivh,iabvB1TEderiv, &
                        iabvB1TMderivh,iabvCz1TMderivh,iabvC0TEderiv,iabvC0TMderivh,iabvC1TEderiv,iabvC1TMderivh, &
                        iabvBz1TEderiv,iabvCz1TM, &
                        iabvB0TMderivv,iabvB1TMderivv,iabvCz1TMderivv,iabvC0TMderivv,iabvC1TMderivv)

                      call interp_intvals_hmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_recv,j_om_mu, &
                        iabvB0TEderiv,iabvB0TMderivh,iabvB1TEderiv,iabvB1TMderivh,iabvCz1TMderivh,iabvC0TEderiv,iabvC0TMderivh, &
                        iabvC1TEderiv,iabvC1TMderivh,iabvBz1TEderiv,ilay,iabvCz1TM, &
                        iabvB0TMderivv,iabvB1TMderivv,iabvCz1TMderivv,iabvC0TMderivv,iabvC1TMderivv, bgdat%dExdmv(:,ilay), &
                        bgdat%dEydmv(:,ilay),bgdat%dEzdmv(:,ilay),bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay),bgdat%dHzdmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd(refl_var,sz,zr,ilay,iblwB0TEderiv,iblwB0TMderiv,iblwB1TEderiv, &
                        iblwB1TMderiv,iblwCz1TMderiv,iblwC0TEderiv,iblwC0TMderiv,iblwC1TEderiv,iblwC1TMderiv, &
                        iblwBz1TEderiv,iblwCz1TM)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_recv,j_om_mu, &
                        iblwB0TEderiv,iblwB0TMderiv,iblwB1TEderiv,iblwB1TMderiv,iblwCz1TMderiv,iblwC0TEderiv,iblwC0TMderiv, &
                        iblwC1TEderiv,iblwC1TMderiv,iblwBz1TEderiv,ilay,iblwCz1TM)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd(refl_var,sz,zr,ilay,iblwB0TEderiv,iblwB0TMderivh,iblwB1TEderiv, &
                        iblwB1TMderivh,iblwCz1TMderivh,iblwC0TEderiv,iblwC0TMderivh,iblwC1TEderiv,iblwC1TMderivh, &
                        iblwBz1TEderiv,iblwCz1TM, &
                        iblwB0TMderivv,iblwB1TMderivv,iblwCz1TMderivv,iblwC0TMderivv,iblwC1TMderivv)

                      call interp_intvals_hmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                        bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),omeps_recv,j_om_mu, &
                        iblwB0TEderiv,iblwB0TMderivh,iblwB1TEderiv,iblwB1TMderivh,iblwCz1TMderivh,iblwC0TEderiv,iblwC0TMderivh, &
                        iblwC1TEderiv,iblwC1TMderivh,iblwBz1TEderiv,ilay,iblwCz1TM, &
                        iblwB0TMderivv,iblwB1TMderivv,iblwCz1TMderivv,iblwC0TMderivv,iblwC1TMderivv, bgdat%dExdmv(:,ilay), &
                        bgdat%dEydmv(:,ilay),bgdat%dEzdmv(:,ilay),bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay),bgdat%dHzdmv(:,ilay))
                    endif
                  endif
                enddo

              endif hmdderiv

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshmd_all !loop over receiver depths

        else

          !> --- Ex and / or Ey -----------------------
          !loop over receiver depths
          recdepthshmdExy: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,hmd)

              hmdfwdExy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Exy_hmd(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey, j_om_mu, &
                    iabvB0TE,iabvB0TM,iabvB1TE,iabvB1TM,0)
                else
                  call interp_intvals_hmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey, j_om_mu, &
                    iblwB0TE,iblwB0TM,iblwB1TE,iblwB1TM,0)
                endif
              endif hmdfwdExy

              hmdderivExy: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hmd,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Exy(refl_var,sz,zr,ilay,iabvB0TEderiv,iabvB0TMderiv,iabvB1TEderiv, &
                        iabvB1TMderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay),j_om_mu, &
                        iabvB0TEderiv,iabvB0TMderiv,iabvB1TEderiv,iabvB1TMderiv,ilay)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Exy(refl_var,sz,zr,ilay,iabvB0TEderiv,iabvB0TMderivh,iabvB1TEderiv, &
                        iabvB1TMderivh, iabvB0TMderivv,iabvB1TMderivv)

                      call interp_intvals_hmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay),j_om_mu, &
                        iabvB0TEderiv,iabvB0TMderivh,iabvB1TEderiv,iabvB1TMderivh,ilay, &
                        iabvB0TMderivv,iabvB1TMderivv, bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Exy(refl_var,sz,zr,ilay,iblwB0TEderiv,iblwB0TMderiv,iblwB1TEderiv, &
                        iblwB1TMderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay),j_om_mu, &
                        iblwB0TEderiv,iblwB0TMderiv,iblwB1TEderiv,iblwB1TMderiv,ilay)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Exy(refl_var,sz,zr,ilay,iblwB0TEderiv,iblwB0TMderivh,iblwB1TEderiv, &
                        iblwB1TMderivh, iblwB0TMderivv,iblwB1TMderivv)

                      call interp_intvals_hmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay),j_om_mu, &
                        iblwB0TEderiv,iblwB0TMderivh,iblwB1TEderiv,iblwB1TMderivh,ilay, &
                        iblwB0TMderivv,iblwB1TMderivv, bgdat%dExdmv(:,ilay),bgdat%dEydmv(:,ilay))
                    endif
                  endif
                enddo
              endif hmdderivExy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshmdExy !loop over receiver depths

          !> --- Ez -----------------------
          !loop over receiver depths
          recdepthshmdEz: do izrec = 1,refl_var%nzrecEz
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecEz,refl_var%nrecperzEz,izrec,sz,zbound,aniso,omega,hmd)

              hmdfwdEz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Ez_hmd(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hmd_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%Ez,omeps_recv,j_om_mu, iabvCz1TM,0)
                else
                  call interp_intvals_hmd_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%Ez,omeps_recv,j_om_mu, iblwCz1TM,0)
                endif
              endif hmdfwdEz

              hmdderivEz: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hmd,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Ez(refl_var,sz,zr,ilay,iabvCz1TMderiv,iabvCz1TM)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_recv,j_om_mu, &
                        iabvCz1TMderiv,ilay,iabvCz1TM)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Ez(refl_var,sz,zr,ilay,iabvCz1TMderivh,iabvCz1TM, iabvCz1TMderivv)

                      call interp_intvals_hmd_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_recv,j_om_mu, &
                        iabvCz1TMderivh,ilay,iabvCz1TM, iabvCz1TMderivv, bgdat%dEzdmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Ez(refl_var,sz,zr,ilay,iblwCz1TMderiv,iblwCz1TM)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_recv,j_om_mu, &
                        iblwCz1TMderiv,ilay,iblwCz1TM)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Ez(refl_var,sz,zr,ilay,iblwCz1TMderivh,iblwCz1TM, iblwCz1TMderivv)

                      call interp_intvals_hmd_Ez(refl_var,src,ifreq,sz,zr,bgdat, bgdat%dEzdm(:,ilay),omeps_recv,j_om_mu, &
                        iblwCz1TMderivh,ilay,iblwCz1TM, iblwCz1TMderivv,bgdat%dEzdmv(:,ilay))
                    endif
                  endif
                enddo

              endif hmdderivEz


            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshmdEz !loop over receiver depths

          !> --- Hx and / or Hy -----------------------
          !loop over receiver depths
          recdepthshmdHxy: do izrec = 1,refl_var%nzrecHxy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHxy,refl_var%nrecperzHxy,izrec,sz,zbound,aniso,omega,hmd)

              hmdfwdHxy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Hxy_hmd(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hx,bgdat%Hy,j_om_mu, &
                    iabvC0TE,iabvC0TM,iabvC1TE,iabvC1TM,0)
                else
                  call interp_intvals_hmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hx,bgdat%Hy,j_om_mu, &
                    iblwC0TE,iblwC0TM,iblwC1TE,iblwC1TM,0)
                endif
              endif hmdfwdHxy

              hmdderivHxy: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hmd,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Hxy(refl_var,sz,zr,ilay,iabvC0TEderiv,iabvC0TMderiv,iabvC1TEderiv, &
                        iabvC1TMderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),j_om_mu, &
                        iabvC0TEderiv,iabvC0TMderiv,iabvC1TEderiv,iabvC1TMderiv,ilay)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Hxy(refl_var,sz,zr,ilay,iabvC0TEderiv,iabvC0TMderivh,iabvC1TEderiv, &
                        iabvC1TMderivh, iabvC0TMderivv,iabvC1TMderivv)

                      call interp_intvals_hmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),j_om_mu, &
                        iabvC0TEderiv,iabvC0TMderivh,iabvC1TEderiv,iabvC1TMderivh,ilay, &
                        iabvC0TMderivv,iabvC1TMderivv, bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay))
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Hxy(refl_var,sz,zr,ilay,iblwC0TEderiv,iblwC0TMderiv,iblwC1TEderiv, &
                        iblwC1TMderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),j_om_mu, &
                        iblwC0TEderiv,iblwC0TMderiv,iblwC1TEderiv,iblwC1TMderiv,ilay)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Hxy(refl_var,sz,zr,ilay,iblwC0TEderiv,iblwC0TMderivh,iblwC1TEderiv, &
                        iblwC1TMderivh, iblwC0TMderivv,iblwC1TMderivv)

                      call interp_intvals_hmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),j_om_mu, &
                        iblwC0TEderiv,iblwC0TMderivh,iblwC1TEderiv,iblwC1TMderivh,ilay, &
                        iblwC0TMderivv,iblwC1TMderivv, bgdat%dHxdmv(:,ilay),bgdat%dHydmv(:,ilay))
                    endif
                  endif
                enddo
              endif hmdderivHxy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshmdHxy !loop over receiver depths

          !> --- Hz -----------------------
          !loop over receiver depths
          recdepthshmdHz: do izrec = 1,refl_var%nzrecHz
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHz,refl_var%nrecperzHz,izrec,sz,zbound,aniso,omega,hmd)

              hmdfwdHz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                !precompute integral values and spline derivatives
                call precomp_intvals_Hz_hmd(refl_var,sz,zr)

                !get integral values at field points
                if(sz.ge.zr) then
                  call interp_intvals_hmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hz,j_om_mu, iabvBz1TE,0)
                else
                  call interp_intvals_hmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hz,j_om_mu, iblwBz1TE,0)
                endif
              endif hmdfwdHz

              hmdderivHz: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,hmd,aniso)

                  if(sz.ge.zr) then
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Hz(refl_var,sz,zr,ilay, iabvBz1TEderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay),j_om_mu, iabvBz1TEderiv,ilay)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Hz(refl_var,sz,zr,ilay, iabvBz1TEderiv)
                      call interp_intvals_hmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay),j_om_mu, iabvBz1TEderiv,ilay)
                    endif
                  else
                    if(aniso.EQ.iso) then
                      !precompute integral values and spline derivatives
                      call precomp_intvals_deriv_hmd_Hz(refl_var,sz,zr,ilay, iblwBz1TEderiv)
                      !get derivatives of field values at receiver points
                      call interp_intvals_hmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay),j_om_mu, iblwBz1TEderiv,ilay)
                    else
                      !VTI
                      call precomp_intvals_deriv_hmd_Hz(refl_var,sz,zr,ilay, iblwBz1TEderiv)
                      call interp_intvals_hmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay),j_om_mu, iblwBz1TEderiv,ilay)
                    endif
                  endif
                enddo
              endif hmdderivHz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthshmdHz !loop over receiver depths

        endif samecoord_hmd

        deallocate(refl_var%xs,refl_var%ys, stat=ierr)
        deallocate(trans_above_src,trans_below_src,dz_above_src,dz_below_src, stat=ierr)

      enddo srczloophmd !unique source element depths

      deallocate(refl_var%isrcperz,refl_var%zsrc,refl_var%nsrcperz,refl_var%betasrc, stat=ierr)

    endif


    !***********************************************************************
    !>  VMD components
    !***********************************************************************

    !get unique source element depths into refl_var structure
    call find_srcdepths(src,refl_var,vmd)

    !if there are any VMD components, compute fields for them
    if(refl_var%nzsrc .gt. 0) then
      !loop over source depths
      srczloopvmd: do izsrc = 1,refl_var%nzsrc

        call prepare_srcdepth(sz,omeps_srcv,refl_var,src,izsrc,zbound,omega)

        !same coordinates for all field components?
        samecoord_vmd: if(bgdat%allcomp_samecoord) then

          !loop over receiver depths
          recdepthsvmd_all: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,vmd)

              vmdfwd: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                call precomp_intvals_vmd(refl_var,sz,zr)

                !get field values at receiver points
                if(sz.ge.zr) then
                  call interp_intvals_vmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,bgdat%Ez, &
                    bgdat%Hx,bgdat%Hy,bgdat%Hz,j_om_mu,ommusq, iabvA1TEvmd,iabvD1TEvmd,iabvA0TEvmd,0)
                else
                  call interp_intvals_vmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,bgdat%Ez, &
                    bgdat%Hx,bgdat%Hy,bgdat%Hz,j_om_mu,ommusq, iblwA1TEvmd,iblwD1TEvmd,iblwA0TEvmd,0)
                endif
              endif vmdfwd

              vmdderiv: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,vmd,aniso)

                  !iso and VTI formulas are the same, epsv not contained in these integrals, no special terms in front of int.
                  if(sz.ge.zr) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_vmd(refl_var,sz,zr,ilay,iabvAz1TEderiv,iabvD1TEvmdderiv,iabvA0TEvmdderiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_vmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                      bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),j_om_mu,ommusq, &
                      iabvAz1TEderiv,iabvD1TEvmdderiv,iabvA0TEvmdderiv,ilay)
                  else
                    call precomp_intvals_deriv_vmd(refl_var,sz,zr,ilay,iblwAz1TEderiv,iblwD1TEvmdderiv,iblwA0TEvmdderiv)
                    call interp_intvals_vmd_allcomp(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                      bgdat%dEzdm(:,ilay),bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay),bgdat%dHzdm(:,ilay),j_om_mu,ommusq, &
                      iblwAz1TEderiv,iblwD1TEvmdderiv,iblwA0TEvmdderiv,ilay)
                  endif
                enddo
              endif vmdderiv

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvmd_all !loop over receiver depths

        else

          !> --- Ex and / or Ey -----------------------
          !loop over receiver depths
          recdepthsvmdExy: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,vmd)

              vmdfwdExy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                call precomp_intvals_Exy_vmd(refl_var,sz,zr)

                !get field values at receiver points
                if(sz.ge.zr) then
                  call interp_intvals_vmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,j_om_mu, iabvA1TEvmd,0)
                else
                  call interp_intvals_vmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Ex,bgdat%Ey,j_om_mu, iblwA1TEvmd,0)
                endif
              endif vmdfwdExy

              vmdderivExy: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,vmd,aniso)

                  !iso and VTI formulas are the same, epsv not contained in these integrals, no special terms in front of int.
                  if(sz.ge.zr) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_vmd_Exy(refl_var,sz,zr,ilay,iabvAz1TEderiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_vmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                      j_om_mu, iabvAz1TEderiv,ilay)
                  else
                    call precomp_intvals_deriv_vmd_Exy(refl_var,sz,zr,ilay,iblwAz1TEderiv)
                    call interp_intvals_vmd_Exy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dExdm(:,ilay),bgdat%dEydm(:,ilay), &
                      j_om_mu, iblwAz1TEderiv,ilay)
                  endif
                enddo
              endif vmdderivExy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvmdExy !loop over receiver depths

          !--- no Ez for VMD source ------

          !> --- Hx and / or Hy -----------------------
          !loop over receiver depths
          recdepthsvmdHxy: do izrec = 1,refl_var%nzrecHxy
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHxy,refl_var%nrecperzHxy,izrec,sz,zbound,aniso,omega,vmd)

              vmdfwdHxy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                call precomp_intvals_Hxy_vmd(refl_var,sz,zr)

                !get field values at receiver points
                if(sz.ge.zr) then
                  call interp_intvals_vmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hx,bgdat%Hy,j_om_mu, iabvD1TEvmd,0)
                else
                  call interp_intvals_vmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hx,bgdat%Hy,j_om_mu, iblwD1TEvmd,0)
                endif
              endif vmdfwdHxy

              vmdderivHxy: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,vmd,aniso)

                  !iso and VTI formulas are the same, epsv not contained in these integrals, no special terms in front of int.
                  if(sz.ge.zr) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_vmd_Hxy(refl_var,sz,zr,ilay,iabvD1TEvmdderiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_vmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                      j_om_mu, iabvD1TEvmdderiv,ilay)
                  else
                    call precomp_intvals_deriv_vmd_Hxy(refl_var,sz,zr,ilay,iblwD1TEvmdderiv)
                    call interp_intvals_vmd_Hxy(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHxdm(:,ilay),bgdat%dHydm(:,ilay), &
                      j_om_mu, iblwD1TEvmdderiv,ilay)
                  endif
                enddo
              endif vmdderivHxy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvmdHxy !loop over receiver depths

          !> --- Hz -----------------------
          !loop over receiver depths
          recdepthsvmdHz: do izrec = 1,refl_var%nzrecHz
            call prepare_recdepth(zr,omeps_recv,refl_var, refl_var%zrecHz,refl_var%nrecperzHz,izrec,sz,zbound,aniso,omega,vmd)

              vmdfwdHz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
                call precomp_intvals_Hz_vmd(refl_var,sz,zr)

                !get field values at receiver points
                if(sz.ge.zr) then
                  call interp_intvals_vmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hz,j_om_mu,ommusq, iabvA0TEvmd,0)
                else
                  call interp_intvals_vmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%Hz,j_om_mu,ommusq, iblwA0TEvmd,0)
                endif
              endif vmdfwdHz

              vmdderivHz: if(dowhat .ge. deriv) then
                do ilay=1,nlay
                  !recompute refl. and transm. coeff. if they have been changed during interpolation
                  call prepare_refcoef(refl_var,refl_var%rmax,vmd,aniso)

                  !iso and VTI formulas are the same, epsv not contained in these integrals, no special terms in front of int.
                  if(sz.ge.zr) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_vmd_Hz(refl_var,sz,zr,ilay,iabvA0TEvmdderiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_vmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay),j_om_mu,ommusq, &
                      iabvA0TEvmdderiv,ilay)
                  else
                    call precomp_intvals_deriv_vmd_Hz(refl_var,sz,zr,ilay,iblwA0TEvmdderiv)
                    call interp_intvals_vmd_Hz(refl_var,src,ifreq,sz,zr,bgdat,bgdat%dHzdm(:,ilay),j_om_mu,ommusq, &
                      iblwA0TEvmdderiv,ilay)
                  endif
                enddo
              endif vmdderivHz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthsvmdHz !loop over receiver depths

        endif samecoord_vmd

        deallocate(refl_var%xs,refl_var%ys, stat=ierr)
        deallocate(trans_above_src,trans_below_src,dz_above_src,dz_below_src, stat=ierr)

      enddo srczloopvmd !unique source element depths

      deallocate(refl_var%isrcperz,refl_var%zsrc,refl_var%nsrcperz,refl_var%betasrc, stat=ierr)

    endif !vmd source components present


    !take complex conjugate to match FFT convention of 3D and 2.5D codes (opposite of Loeseth!)
    !do this here and not at the very end because for wire source, we take the complex conjugate BEFORE adding wire fields,
    !so taking conjugate is not the last step in wire field computation
    call conjugate_fields(bgdat,refl_var,src)


  !-----------------------------------------------------------------
  !> horizontal wire sources
  !-----------------------------------------------------------------
  case (wire)

    !for first current: compute fields, store fields for separate wires
    !for subsequent currents: just multiply precomputed fields with current and add up
    firstcur: if(icur.EQ.1) then

      !initialize arrays for separate contributions from each wire
      call init_wirefields(src,refl_var,bgdat)

      !get unique wire depths depths into refl_var structure
      call find_srcdepths(src,refl_var,0)
      !loop over source depths
      srczloopwire: do izsrc = 1,refl_var%nzsrc

        call prepare_srcdepth(sz,omeps_srcv,refl_var,src,izsrc,zbound,omega)

        !same coordinates for all field components?
        samecoord_wire: if(bgdat%allcomp_samecoord) then

          !loop over receiver depths
          recdepthswire_all: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var,  refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,0)

            wirefwd: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
              call precomp_intvals_wire(refl_var,sz,zr)

              !get integral values at grid points
              if(sz.ge.zr) then
                call interp_intvals_wire_allcomp(refl_var,bgdat,refl_var%EHwire,src,sz,zr,omeps_recv,ommu, &
                  i1abvExwire,iabvD0TE,iabvAz1TE,i2abvExwire,iabvD0TM,idabvHxwire,0)
              else
                call interp_intvals_wire_allcomp(refl_var,bgdat,refl_var%EHwire,src,sz,zr,omeps_recv,ommu, &
                  i1blwExwire,iblwD0TE,iblwAz1TE,i2blwExwire,iblwD0TM,idblwHxwire,0)
              endif
            endif wirefwd

            wirederiv: if(dowhat .ge. deriv) then
              do ilay=1,nlay
                !recompute refl. and transm. coeff. if they have been changed during interpolation
                call prepare_refcoef(refl_var,refl_var%rmax,0,aniso)

                if(sz.ge.zr) then
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire(refl_var,sz,zr,ilay,i1abvExwirederiv,iabvD0TEderiv,iabvAz1TEderiv, &
                      i2abvExwirederiv,iabvD0TMderiv,idabvHxwirederiv,iabvD0TM)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_allcomp(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,ommu,&
                      i1abvExwirederiv,iabvD0TEderiv,iabvAz1TEderiv,i2abvExwirederiv,iabvD0TMderiv,idabvHxwirederiv,ilay, &
                      iabvD0TM)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire(refl_var,sz,zr,ilay,i1abvExwirederiv,iabvD0TEderiv,iabvAz1TEderiv, &
                      i2abvExwirederivh,iabvD0TMderivh,idabvHxwirederivh,iabvD0TM, &
                      i2abvExwirederivv,iabvD0TMderivv,idabvHxwirederivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_allcomp(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,ommu,&
                      i1abvExwirederiv,iabvD0TEderiv,iabvAz1TEderiv,i2abvExwirederivh,iabvD0TMderivh,idabvHxwirederivh,ilay, &
                      iabvD0TM, i2abvExwirederivv,iabvD0TMderivv,idabvHxwirederivv, refl_var%EHwirederivv(:,ilay))
                  endif
                else
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire(refl_var,sz,zr,ilay,i1blwExwirederiv,iblwD0TEderiv,iblwAz1TEderiv, &
                      i2blwExwirederiv,iblwD0TMderiv,idblwHxwirederiv,iblwD0TM)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_allcomp(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,ommu,&
                      i1blwExwirederiv,iblwD0TEderiv,iblwAz1TEderiv,i2blwExwirederiv,iblwD0TMderiv,idblwHxwirederiv,ilay, &
                      iblwD0TM)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire(refl_var,sz,zr,ilay,i1blwExwirederiv,iblwD0TEderiv,iblwAz1TEderiv, &
                      i2blwExwirederivh,iblwD0TMderivh,idblwHxwirederivh,iblwD0TM, &
                      i2blwExwirederivv,iblwD0TMderivv,idblwHxwirederivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_allcomp(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,ommu,&
                      i1blwExwirederiv,iblwD0TEderiv,iblwAz1TEderiv,i2blwExwirederivh,iblwD0TMderivh,idblwHxwirederivh,ilay, &
                      iblwD0TM, i2blwExwirederivv,iblwD0TMderivv,idblwHxwirederivv, refl_var%EHwirederivv(:,ilay))
                  endif
                endif
              enddo
            endif wirederiv

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthswire_all !receiver (cell) depths

        else

          !--- Ex and/or Ey -------------------------
          !loop over receiver depths
          recdepthswireExy: do izrec = 1,refl_var%nzrecExy
            call prepare_recdepth(zr,omeps_recv,refl_var,  refl_var%zrecExy,refl_var%nrecperzExy,izrec,sz,zbound,aniso,omega,0)

            wirefwdExy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
              call precomp_intvals_Exy_wire(refl_var,sz,zr)

              !get integral values at grid points
              if(sz.ge.zr) then
                call interp_intvals_wire_Exy(refl_var,bgdat,refl_var%EHwire,src,sz,zr, i1abvExwire,i2abvExwire,0)
              else
                call interp_intvals_wire_Exy(refl_var,bgdat,refl_var%EHwire,src,sz,zr, i1blwExwire,i2blwExwire,0)
              endif
            endif wirefwdExy

            wirederivExy: if(dowhat .ge. deriv) then
              do ilay=1,nlay
                !recompute refl. and transm. coeff. if they have been changed during interpolation
                call prepare_refcoef(refl_var,refl_var%rmax,0,aniso)

                if(sz.ge.zr) then
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Exy(refl_var,sz,zr,ilay,i1abvExwirederiv, i2abvExwirederiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Exy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,&
                      i1abvExwirederiv,i2abvExwirederiv,ilay)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Exy(refl_var,sz,zr,ilay,i1abvExwirederiv,i2abvExwirederivh, i2abvExwirederivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Exy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,&
                      i1abvExwirederiv,i2abvExwirederivh,ilay, i2abvExwirederivv, refl_var%EHwirederivv(:,ilay))
                  endif
                else
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Exy(refl_var,sz,zr,ilay,i1blwExwirederiv, i2blwExwirederiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Exy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,&
                      i1blwExwirederiv,i2blwExwirederiv,ilay)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Exy(refl_var,sz,zr,ilay,i1blwExwirederiv, i2blwExwirederivh, i2blwExwirederivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Exy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,&
                      i1blwExwirederiv,i2blwExwirederivh,ilay, i2blwExwirederivv, refl_var%EHwirederivv(:,ilay))
                  endif
                endif
              enddo
            endif wirederivExy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthswireExy !receiver (cell) depths

          !--- Ez ---------------------------
          !loop over receiver depths
          recdepthswireEz: do izrec = 1,refl_var%nzrecEz
            call prepare_recdepth(zr,omeps_recv,refl_var,  refl_var%zrecEz,refl_var%nrecperzEz,izrec,sz,zbound,aniso,omega,0)

            wirefwdEz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
              call precomp_intvals_Ez_wire(refl_var,sz,zr)

              !get integral values at grid points
              if(sz.ge.zr) then
                call interp_intvals_wire_Ez(refl_var,bgdat,refl_var%EHwire,src,sz,zr,omeps_recv, iabvD0TM,0)
              else
                call interp_intvals_wire_Ez(refl_var,bgdat,refl_var%EHwire,src,sz,zr,omeps_recv, iblwD0TM,0)
              endif
            endif wirefwdEz

            wirederivEz: if(dowhat .ge. deriv) then
              do ilay=1,nlay
                !recompute refl. and transm. coeff. if they have been changed during interpolation
                call prepare_refcoef(refl_var,refl_var%rmax,0,aniso)

                if(sz.ge.zr) then
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Ez(refl_var,sz,zr,ilay,iabvD0TMderiv,iabvD0TM)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Ez(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,&
                      iabvD0TMderiv,ilay, iabvD0TM)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Ez(refl_var,sz,zr,ilay,iabvD0TMderivh,iabvD0TM, iabvD0TMderivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Ez(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,&
                      iabvD0TMderivh,ilay, iabvD0TM, iabvD0TMderivv, refl_var%EHwirederivv(:,ilay))
                  endif
                else
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Ez(refl_var,sz,zr,ilay,iblwD0TMderiv,iblwD0TM)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Ez(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,&
                      iblwD0TMderiv,ilay, iblwD0TM)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Ez(refl_var,sz,zr,ilay,iblwD0TMderivh,iblwD0TM, iblwD0TMderivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Ez(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,omeps_recv,&
                      iblwD0TMderivh,ilay, iblwD0TM, iblwD0TMderivv, refl_var%EHwirederivv(:,ilay))
                  endif
                endif
              enddo
            endif wirederivEz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthswireEz !receiver (cell) depths

          !--- Hx and/or Hy -------------------------
          !loop over receiver depths
          recdepthswireHxy: do izrec = 1,refl_var%nzrecHxy
            call prepare_recdepth(zr,omeps_recv,refl_var,  refl_var%zrecHxy,refl_var%nrecperzHxy,izrec,sz,zbound,aniso,omega,0)

            wirefwdHxy: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
              call precomp_intvals_Hxy_wire(refl_var,sz,zr)

              !get integral values at grid points
              if(sz.ge.zr) then
                call interp_intvals_wire_Hxy(refl_var,bgdat,refl_var%EHwire,src,sz,zr, iabvD0TE,idabvHxwire,0)
              else
                call interp_intvals_wire_Hxy(refl_var,bgdat,refl_var%EHwire,src,sz,zr, iblwD0TE,idblwHxwire,0)
              endif
            endif wirefwdHxy

            wirederivHxy: if(dowhat .ge. deriv) then
              do ilay=1,nlay
                !recompute refl. and transm. coeff. if they have been changed during interpolation
                call prepare_refcoef(refl_var,refl_var%rmax,0,aniso)

                if(sz.ge.zr) then
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Hxy(refl_var,sz,zr,ilay,iabvD0TEderiv,idabvHxwirederiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Hxy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr, &
                      iabvD0TEderiv,idabvHxwirederiv,ilay)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Hxy(refl_var,sz,zr,ilay,iabvD0TEderiv,idabvHxwirederivh, idabvHxwirederivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Hxy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr, &
                      iabvD0TEderiv,idabvHxwirederivh,ilay, idabvHxwirederivv, refl_var%EHwirederivv(:,ilay))
                  endif
                else
                  if(aniso.EQ.iso) then
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Hxy(refl_var,sz,zr,ilay,iblwD0TEderiv,idblwHxwirederiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Hxy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr, &
                      iblwD0TEderiv,idblwHxwirederiv,ilay, iblwD0TM)
                  else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Hxy(refl_var,sz,zr,ilay,iblwD0TEderiv,idblwHxwirederivh, idblwHxwirederivv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Hxy(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr, &
                      iblwD0TEderiv,idblwHxwirederivh,ilay, idblwHxwirederivv, refl_var%EHwirederivv(:,ilay))
                  endif
                endif
              enddo
            endif wirederivHxy

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthswireHxy !receiver (cell) depths

          !--- Hz ---------------------------
          !loop over receiver depths
          recdepthswireHz: do izrec = 1,refl_var%nzrecHz
            call prepare_recdepth(zr,omeps_recv,refl_var,  refl_var%zrecHz,refl_var%nrecperzHz,izrec,sz,zbound,aniso,omega,0)

            wirefwdHz: if((dowhat.EQ.fwdmodel) .OR. (dowhat.EQ.fwd_deriv)) then
              call precomp_intvals_Hz_wire(refl_var,sz,zr)

              !get integral values at grid points
              if(sz.ge.zr) then
                call interp_intvals_wire_Hz(refl_var,bgdat,refl_var%EHwire,src,sz,zr,ommu, iabvAz1TE,0)
              else
                call interp_intvals_wire_Hz(refl_var,bgdat,refl_var%EHwire,src,sz,zr,ommu, iblwAz1TE,0)
              endif
            endif wirefwdHz

            wirederivHz: if(dowhat .ge. deriv) then
              do ilay=1,nlay
                !recompute refl. and transm. coeff. if they have been changed during interpolation
                call prepare_refcoef(refl_var,refl_var%rmax,0,aniso)

                if(sz.ge.zr) then
                  !there are no vertical derivatives, isotropic and VTI cases require exactly the same functions
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Hz(refl_var,sz,zr,ilay,iabvAz1TEderiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Hz(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,ommu, iabvAz1TEderiv,ilay)
                else
                    !precompute integral values and spline derivatives
                    call precomp_intvals_deriv_wire_Hz(refl_var,sz,zr,ilay,iblwAz1TEderiv)
                    !get derivatives of field values at receiver points
                    call interp_intvals_wire_Hz(refl_var,bgdat,refl_var%EHwirederiv(:,ilay),src,sz,zr,ommu, iblwAz1TEderiv,ilay)
                endif
              enddo
            endif wirederivHz

            deallocate(trans_above_rec,trans_below_rec,dz_above_rec,dz_below_rec, stat=ierr)
          enddo recdepthswireHz !receiver (cell) depths

        endif samecoord_wire

        deallocate(refl_var%xs,refl_var%ys, stat=ierr)
        deallocate(trans_above_src,trans_below_src,dz_above_src,dz_below_src, stat=ierr)

      enddo srczloopwire !wire depths

      deallocate(refl_var%isrcperz,refl_var%zsrc,refl_var%nsrcperz,refl_var%betasrc, stat=ierr)

    endif firstcur

    !take complex conjugate to match FFT convention of 3D and 2.5D codes (opposite of Loeseth!)
    !for derivatives: also apply factor to get derivatives with respect to ln(sigma0)
    call conjugate_fields(bgdat,refl_var,src)

    call addwirefields(bgdat,refl_var,src,icur,ifreq)

    !last current: clean up
    if(icur.EQ.src%ncur) call clean_wirefields(src,refl_var,bgdat)

  end select sourcetype


  call clean_zrec(refl_var,bgdat)
  deallocate(refl_var%radlog,refl_var%intvaltmp, stat=ierr)
  deallocate(refl_var%intvalre,refl_var%intvalim,refl_var%spl_derivre,refl_var%spl_derivim, stat=ierr)
  nullify(rup,rdn,tup,tdn)
  !deallocate(rupallTE,rupallTM,rdnallTE,rdnallTM,tupallTE,tupallTM,tdnallTE,tdnallTM,pvertall1,pvertall2, stat=ierr)
  deallocate(epsv,epsh,epsmuv,epsmuh,epsmuratio,omsq_epsmuv,omsq_epsmuh, stat=ierr)
!!$  deallocate(pvert, stat=ierr)
  deallocate(branchpt, stat=ierr)
  nullify(zbound)

endsubroutine reflectivity_unified


