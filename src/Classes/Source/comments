Source object has 4 cVectors: E, rhs, e0, bdry.   In fact, the way we are using this at present,
there is no real need for Src%e0 or Src%bdry -- these are easily obtained as src%E%interior and src%E%boundary,
so there is no reason to add storage for these.   Then no need for SetE0 or Swet Bdry procedures.
In some cases additonal variables might be required, but these can be added in the extensions
(e0, bdry were in the matlab versions, so this comes from me.  But in retrospect (now that we have these 
interior and boundary functions, there is no reason to store these extra variables)

I do not think the default 1D conductivity profile for BC should be the average!   This is NOT what we used to do;
rather conductivity on the boundary was typically used.   And in many cases (even for inversion) the conductivity
goes to the background at the edges, and this background is what is used at the edges -- and this makes sense
to me.

I notice that forward_solver%SetPeriod is called in test_FWD -- and then again in solveFWD  (for each transmitter)
Only need one call -- where should this be?   Tradeoff between making easy to use, and having more control.   Need
to discuss (Naser!)

Tx%SolveFwd  sets source -- do we really want this to be embedded in SolveFwd?   DEFINITELY NOT for inversion!
The way the Source class is set up now, we would want to use previous solution to "Set E" -- so we can start from
previous e0, and avoid resetting BC (the theory for sensitivity assumes that boundary data (i.e., src%E%boundary)
is fixed, and does not change during the inversion.   So we DO NOT want to keep resolving the 1D problem (e.g., with
average conductivity that might change during inversion!)

We need to discuss this VectorArray (linked list) idea.  I guess I DO NOT LIKE THIS AT ALL, but I might be convinced.
At this point it is a complication -- but once we get to memory managment and parallelization I guess it is in the
rubbish bin anyway!

SetE is an abstract Source class procedure.  But this requires an integer to define "polarization", something
that is rather MT specific.  Might want to think now about more general use of Source class -- will need to use this
for adjoint problems, CSEM -- how would Source class look?  Should make the abstract class consistent with all uses
I think.


